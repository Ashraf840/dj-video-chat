#### Build a video chat app using django & WebRTC ####
1. [SDP] Establish a peer-to-peer connection between two peers. In order to establish a p2p connection,
   both peers need special info about each other called SDP (Session Description Protocol).

2. [Signalling Server] Each peer needs to share their SDP with each other, thus they need an intermediary server
   commonly known as signalling servers.

   The signalling server will be established using the django-channels.

3. [WebSockets] Both peers will connect using the WebSockets.

4. [Network Info about the peers' machines]: When the signalling servers knows the location of each peer,
    it can relay messages between the two peers. In that way, the two peers will change their SDPs.

    Once both peers exchange their SDPs, they can establish a p2p connection.

5. After establishing the p2p connection, the peers will noe require a signalling server. Because they can
    communicate with each other using the peer to peer connection.

#######################################################




1. Create a new django app called "chat" & install that inside the project.
    Create the "static" directory for storing the js, css files.
    Create "templates" directory & define that into the system.

2. Setup the basic template for the video chat app. Basic template is setup.

3. [Install Requirement]:     pip install channels

4. Implement the code for establishing the ASGI application config into the "asgi.py" file.
    Explicitly define the ASGI application object into the settins.py file of the project.

5. Create the "consume.py" file inside the "chat" application of the project.
    [NOTE]:  "consumers" as similar to the "views". But this will handle the "WebSOcket" requests.

    Inside the "consumers", we create a class extending the "AsyncWebsocketConsumer" which will be
    consisting of some asynchronous functions.

    The class will consist of the async func accordingly:  connect(), receive() & disconnect() funcs.

    [NOTE]:  Django-channels generates "groups/rooms" in order to connect with the consumers. The groups keep channel names.
    Each peer that connects to our django-channels server, will have a unique channel-name.
    Groups essentially stores the collection of these channel-names. These are like rooms, each peer joins inside the room through channels.
    Whenever a peer sends a msg, that will be sent to all the channels that are in the group, and that msg will be broadcast to all the peers who are inside that group.

[connect() method]
6. Create room-group name, & then the peer which connects to the consumer "ChatConsumer" needs to be added inside the channel-layer-group.
    While adding the room-name inside the channel-layer, we've to paas the room-group-name & channel-name of the peer that is trying to connect.
    Lastly we accept the peer connection using the "self.accept()" func.

[disconnect() method]
7. Create the "disconnect()" func to discard/ remove the channel name from the group/room.

[receive() method]
8. Depending on specific use-cases, we define the "receive()" func. This func will initially de-serialize the json-dict sent from the client.
    Then extract the message from the de-serialized/converted python-dict.
    Through the "group_send()" method of this func, the django-channels will broadcast the msg to all the channels of the group.
    [Main Func: "group_send()"]
    It'll use the "group_send()" func, and the func expects the "room_group_name" & a dict. This dict will contain another dependency-func ("send_message") which
    is responsible for sending the msg to the client-side.

    [NOTE]:  Everytime the "group_send()" method sends a msg through a channel, it invokes the "send_message()" method of this class (ChatConsumer).
    Since we're using the channel_layers, we need to specify the message_broker/cache_memory in the 'settings.py' file, which will be used by the django-channels.

    [Dependency Func: "send_message()"]
    This func will extract the message from the 'event' param. Then it'll send the message asynchronously to the client-side after serializing into json-dict.

[IMPORTANT]:  Most of the code will be written for sending our SDPs to other peers & notifying every peer whenever a new peer joins the room.

[Explanation]
    The "group_send()" func will broadcast the data to all the peers in the room using another function "send_message()" through the 'type' key-value pair.
    And the "send_message()" func uses the "send()" method to send the payload to the websocket after serializing the payload into json-dict.

[Channel-layers config in 'settings.py' file]
9. Implement the channel-layers config into the 'settings.py' file, thus which message-broker/cache server it'll use will be explicitly defined in the config.
    [NOTE]:  Here, I'm using the redis-server as the message-broker/cache database.

10. Create the "routing.py" file to handle the consumer. The routing files are similar to "urls.py" file. It'll route the client-request to the appropriate consumers.


----------------------- Forntend JavaScript

[inside 'main.js']

11. Fetch the user-input from the input-field meant for the inserting room-name.
    Get the current location along with other information of the client-request. It'll be stored in a variable as an object since the "window.location" returns object.

12. Create an event-listener to the join-room-btn. Inside this func, the websocket-url will be made after fetching the userName-input.
    With the help of data get from the "window.location", the websocket-url will be created.
    After generating the websocket-url, instantiate a websocket-instance & pass that url inside the websocket-instantiation-param.
    This will connect with the url build inside the 'src/chat/routing.py' file.
    [NOTE] And a new-instance of the chat-consumer will be created for each connection made with the websocket-url using the websocket.

13. Create the complete lifecycle of websocket connection using the socket instance: socket.onopen, socket.onmessage, socket.onclose, socket.onerror

    [NB]: With this config, the websocket connection will throw an error, since we didn't mention the websocker-routing in our 'asgi.py' file,

    [Install software (home-desktop) ]:   Install redis-server inside the home-desktop.

    [Install Requirement]:     pip install channels-redis

14. Since the websocket url uses the locations-pathname from the url, we attach the 'chat/' url-string in the consumer-routing inside the 'routing.py' file.

    [NB]:  Testing the websocket connection using the websocketking.
        Ref:  https://websocketking.com/


15. As soon as, the websocket makes a successful connection with the backend channels-consumer, construct a js-object (dictionary) &
    then serialize that js-obj with the key called 'message' using the "JSON.stringify()".
    [NB]:  The reason for constructing the js-obj with the key called 'message' is that the backend consumer-class ("ChatConsumer") is established the "receive()" method in such a way that it
    expects to extract the JSON-obj sent from the frontend by calling the 'message' key.

|----------------------------------------------['Payload' transferring life-cycle]----------------------------------------------|

>>>> class-consumer (ChatConsumer) // Backend:
"connect()" method:     This method will use the "channel_layer" to add a group with the "room_group_name" & "channel_name" by using the "group_add()" method.
        Then it'll accept the peer connection using the "accept()" method.

"receive()" method:     This method will use the "channel_layer" to broadcast the message to each client-channels thorugh provoking the "send_message()" message.
        Thus, the "group_send()" method expects a dictionary where the 'romm_group_name' is explicitly defined, a dictionary where the 'send_message()' method
        gets provoked using the key-value pair. Inside that dictionary, the received_message will also be assigned as a key-value pair. This dictionary is used to provoke the "send_message()" method & pass the message (payload) to the 'send_message()' method.

        "send_message()" method:    This method's job is to send the message to each client-channel. Before sending to each channel, it firstly extract the message sent from the "group_send()" method of the "receive()" method.
        But before sending the message to every channel, we need to serialize that into json-obj using the "json.dumps()" method.

"disconnect()" method:      This method will discard the client-channel from the group using the channel_layer and the "group_discard()" will be able to remove the client-channel from the group using the info of "room_group_name" & "channel_name"


>>>> Websocket // Frontend:
"websocket" instance:   Instantiate the websocket object inside the javascript file.

websocket.onopen (socket.onopen):   Using the "socket.onopen()" method, the connection will be built with the backend channel consumer. We will also send any kind of payload from the frontend to the backend-channel-consumer using the "socket.send()" method.

websocket.onmessage (socket.onmessage):     This func will be responsible for receiving any payload from the backend-channel-consumer. Firstly, it'll de-serialize the payload which is in the json-obj format using the "json.stringify()" funtion. Then extract the payload using the "message"-key.
    Then from this function, we can use vanilla-js to make the DOM manipulation.

websocket.onclose (socket.onclose):     This func will be responsible for closing the connection between the frontend-websocket with the backend-channel-consumer.

|----------------------------------------------['Payload' transferring life-cycle]----------------------------------------------|


16. Inside the frontend websocket, the "onopen()" connection will open the websocket connection & through using this function, we should sent message to the backend-channels-consumer, then that consumer will receive the payload using the 'receive()' method.
    Then that "receive()" method will use the "group_send()" method which provokes the "send_message" to broadcast that received payload to each channels connected with that room.
    When sent the "payload" again to the frontend, the "onmessage()" function will receive that and display to each client joined in that room.



|----------------------------------------------[Fetch the local audio & video from the webcam & microphone]----------------------------------------------|

17. Instantiate the MediaStream object and assign that into a variable. Lately, which will contain our local audio & video.
    This will also be the source of our video element for streaming video which is inside the HTML file.

18. A dictionary (js-object) will be created which will specify whether we want to stream audio or video. Initially we want to stream both audio & video.
    Thus, it'll contain a key-value pair where the values will be in a boolean format.

[NB]:  This will be outside the scope of the 'click' event-listener.

19. ["MediaStream" object] Create an empty "MediaStream" object.
    [NOTES]: This represents a stream of media contents. A stream consists of several tracks such as audio, video tracks.

['navigator' object]:  The navigator object contains information about the browser.

20. [mediaDevices.getUserMedia() object]:  With the use of 'navigator' object along with the 'mediaDevices.getUserMedia()' method, the user will be
    prompted for the permission to use the media input which produces the MediaStream with tracks containing the requested types of media.
    Inside the function param, we'll pass the 'constraints' dictionary , which will contain the boolean-value of audio & video media-stream.
    [NB]:  As soon as the 'getUserMedia' finished its execution, it'll return a MediaStream object, which then will be fetched by the "then()" func.
    Attach a "then()" func with the 'mediaDevices.getUserMedia(constraints)' func that will return a promise. Inside this 'then()' method, we'll assign
    the prompted-mediaStream object with the empty-MediaStream object. Then the source of the DOM-video-element will be assigned from the 'localStream' object (firstly it's an empty-mediaStream object.
    But the audio of 'localVideo' will be muted by default, since we don't want to hear the sound of our own voice through streaming the local-media (including audio-video).

21. With the use of "then()" promise method, for handling any error, we'll use the catch method to display any kind of error to the client's console.


